/*
 * syexpr.c - C expression evaluator based on shunting yard algo
 *
 * Evaluate C integer expressions (like the ones generated by cpp)
 *
 * (C) Copyright Pantelis Antoniou <pantelis.antoniou@konsulko.com>
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     (1) Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *
 *     (2) Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in
 *     the documentation and/or other materials provided with the
 *     distribution.
 *
 *     (3)The name of the author may not be used to
 *     endorse or promote products derived from this software without
 *     specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
#include "config.h"

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <errno.h>
#include <ctype.h>
#include <stdbool.h>
#include <assert.h>
#include <stdint.h>

#include "utils.h"

#include "syexpr.h"

struct sy_opdesc {
	const char *op;
	unsigned int prec;
#ifdef SY_DEBUG
	const char *desc;
#endif
};

#undef OPDECL

#ifdef SY_DEBUG
#define OPDECL(_name, _op, _prec, _desc) \
	[ _name ] = { .op = _op, .prec = _prec, .desc = _desc }
#else
#define OPDECL(_name, _op, _prec, _desc) \
	[ _name ] = { .op = _op, .prec = _prec }
#endif

/* tokens, ordered by longest op first */
#define NONE	0
#define LOR	1
#define LAND	2
#define EQ	3
#define NE	4
#define LE	5
#define GE	6
#define SHL	7
#define SHR	8
#define LT	9
#define GT	10
#define OR	11
#define XOR	12
#define AND	13
#define ADD	14
#define SUB	15
#define MUL	16
#define DIV	17
#define MOD	18
#define UPLUS	19
#define UMINUS	20
#define LNOT	21
#define NOT	22
#define LPAREN	23
#define RPAREN	24
#define QMARK	25
#define COLON	26

#define LITERAL	255

/* longest op matches first */
static const struct sy_opdesc ops[] = {
	OPDECL(NONE,   "",  -1, "<none>"),
	OPDECL(LOR,   "||", 12, "logical or"),
	OPDECL(LAND,  "&&", 11, "logical and"),
	OPDECL(EQ,    "==",  7, "equals"),
	OPDECL(NE,    "!=",  7, "not equals"),
	OPDECL(LE,    "<=",  6, "less or equal"),
	OPDECL(GE,    ">=",  6, "greater or equal"),
	OPDECL(SHL,   "<<",  5, "shift left"),
	OPDECL(SHR,   ">>",  5, "shift right"),
	OPDECL(LT,    "<",   6, "less"),
	OPDECL(GT,     ">",  6, "greater"),
	OPDECL(OR,     "|", 10, "binary or"),
	OPDECL(XOR,    "^",  9, "binary xor"),
	OPDECL(AND,    "&",  8, "binary and"),
	OPDECL(ADD,    "+",  4, "add"),
	OPDECL(SUB,    "-",  4, "sub"),
	OPDECL(MUL,    "*",  3, "multiply"),
	OPDECL(DIV,    "/",  3, "divide"),
	OPDECL(MOD,    "%",  3, "modulus"),
	OPDECL(UPLUS,  "+",  2, "unary plus"),
	OPDECL(UMINUS, "-",  2, "unary minus"),
	OPDECL(LNOT,   "!",  2, "logical not"),
	OPDECL(NOT,    "~",  2, "binary not"),
	OPDECL(LPAREN, "(",  0, "left parentheses"),
	OPDECL(RPAREN, ")",  0, "right parentheses"),
	OPDECL(QMARK,  "?", 13, "ternary qmark"),
	OPDECL(COLON,  ":", 13, "ternary colon"),
};

#undef OPDECL

static inline sy_op_t sy_op_at(struct sy_state *sy, int pos);
static inline sy_val_t sy_val_at(struct sy_state *sy, int pos);

#ifdef SY_DEBUG

static inline const char *op_op(int token)
{
	if (token == NONE || (unsigned int)token >= ARRAY_SIZE(ops))
		return NULL;
	return ops[token].op;
}

static inline const char *op_desc(int token)
{
	if (token == NONE || (unsigned int)token >= ARRAY_SIZE(ops))
		return NULL;
	return ops[token].desc;
}

#define sy_debug(_sy, _fmt, ...) \
	do { \
		const struct sy_state *__sy = (_sy); \
		if (__sy->debugf) \
			__sy->debugf(__sy->debugarg, _fmt, ##__VA_ARGS__); \
	} while (0)

static void sy_dump_opstack(struct sy_state *sy)
{
	int i;

	sy_debug(sy, "{");
	for (i = sy->opstack_next - 1; i >= 0; i--)
		sy_debug(sy, " %s", op_op(sy_op_at(sy, i)));
	sy_debug(sy, " }");
}

static void sy_dump_valqueue(struct sy_state *sy)
{
	int i;
	sy_val_t val;
	char vstr[SY_VAL_STR_LEN_MAX];

	if (!sy->debugf)
		return;

	sy_debug(sy, "[");
	for (i = 0; i < sy->valq_next; i++) {
		val = sy_val_at(sy, i);
		sy_debug(sy, " %s", sy_val_str(&val, vstr, sizeof(vstr)));
	}
	sy_debug(sy, " ]");
}

static void sy_dump_token(struct sy_state *sy, int token, const sy_val_t *valp)
{
	char vstr[SY_VAL_STR_LEN_MAX];

	if (token == NONE)
		sy_debug(sy, "\"%s\"\n", "none");
	else if (token == LITERAL)
		sy_debug(sy, "%s\n",
				sy_val_str(valp, vstr, sizeof(vstr)));
	else
		sy_debug(sy, "\"%s\"\n", op_desc(token));
}

#else

static inline const char *op_op(int token)
{
	return NULL;
}

static inline const char *op_desc(int token)
{
	return NULL;
}

#define sy_debug(_sy, _fmt, ...) \
	do { /* nothing */ } while (0)

static inline void sy_dump_opstack(struct sy_state *sy)
{
	/* nothing */
}

static inline void sy_dump_valqueue(struct sy_state *sy)
{
	/* nothing */
}

static inline void sy_dump_token(struct sy_state *sy, int token,
	const sy_val_t *valp)
{
	/* nothing */
}

#endif

static inline bool is_operand(int token)
{
	return token == LITERAL || token == RPAREN;
}

/* NONE counts as operator for this */
static inline bool is_operator(int token)
{
	return !is_operand(token);
}

static inline bool is_unary(int token)
{
	return token == UPLUS || token == UMINUS ||
	       token == LNOT || token == NOT;
}

static inline bool is_binary(int token)
{
	if (token == LPAREN || token == RPAREN ||
	    token == QMARK || token == COLON)
		return false;
	return !is_unary(token);
}

static inline bool is_ternary(int token)
{
	return token == QMARK;
}

static inline bool is_right_assoc(int token)
{
	return token == QMARK || token == COLON ||
	       token == UPLUS || token == UMINUS ||
	       token == LNOT || token == NOT;
}

static inline bool is_left_assoc(int token)
{
	if (token == NONE)
		return false;
	return !is_right_assoc(token);
}

static inline bool is_pushable(int token)
{
	/* return token != RPAREN && token != COLON; */
	return token != RPAREN;
}

static inline int op_prec(int token)
{
	if (token == NONE || token >= ARRAY_SIZE(ops))
		return -1;
	return ops[token].prec;
}

static inline int sy_workbuf_space(struct sy_state *sy)
{
	int space;

	space = (intptr_t)sy->opstack - (intptr_t)sy->valq;
	return space < 0 ? -1 : space;
}

static inline int sy_get_last_token(struct sy_state *sy)
{
	return sy->last_token;
}

static inline void sy_set_last_token(struct sy_state *sy, int token)
{
	sy->last_token = token;
}

static inline int sy_set_error(struct sy_state *sy, int code)
{
	return sy->errcode = code;
}

static int sy_queue_count(struct sy_state *sy)
{
	return sy->valq_next;
}

static int sy_opstack_count(struct sy_state *sy)
{
	return sy->opstack_next;
}

static inline sy_op_t sy_op_at(struct sy_state *sy, int pos)
{
	if ((unsigned int)pos >= sy->opstack_next)
		return NONE;

	return sy->opstack[-1 - pos];
}

static inline sy_val_t sy_val_at(struct sy_state *sy, int pos)
{
	if ((unsigned int)pos >= sy->valq_next)
		return (sy_val_t) { 0, false, false };

	return sy->valq[pos];
}

static inline sy_op_t sy_op_top(struct sy_state *sy)
{
	if (sy->opstack_next < 1)
		return NONE;

	return sy_op_at(sy, sy->opstack_next - 1);
}

static int sy_queue_val(struct sy_state *sy, const sy_val_t *valp)
{
#ifdef SY_DEBUG
	char vstr[SY_VAL_STR_LEN_MAX];
#endif

	if (sy_workbuf_space(sy) <= sizeof(*valp))
		return SY_OUT_OF_MEMORY;

#ifdef SY_DEBUG
	sy_debug(sy, "\t");
	sy_dump_valqueue(sy);
#endif

	sy->valq[sy->valq_next++] = *valp;

#ifdef SY_DEBUG
	sy_debug(sy, " QUE %s -> ", sy_val_str(valp, vstr, sizeof(vstr)));
	sy_dump_valqueue(sy);
	sy_debug(sy, "\n");
#endif

	return 0;
}

static int sy_dequeue_val(struct sy_state *sy, sy_val_t *valp)
{
#ifdef SY_DEBUG
	char vstr[SY_VAL_STR_LEN_MAX];
#endif

	if (sy->valq_next <= 0)
		return SY_INTERNAL_ERROR;

#ifdef SY_DEBUG
	sy_debug(sy, "\t");
	sy_dump_valqueue(sy);
#endif

	*valp = sy->valq[--sy->valq_next];

#ifdef SY_DEBUG
	sy_debug(sy, " DEQ %s -> ", sy_val_str(valp, vstr, sizeof(vstr)));
	sy_dump_valqueue(sy);
	sy_debug(sy, "\n");
#endif

	return 0;
}

static int sy_push_op(struct sy_state *sy, int token)
{
	if ((unsigned int)token >= ARRAY_SIZE(ops))
		return SY_INTERNAL_ERROR;

	if (sy_workbuf_space(sy) <= sizeof(sy_op_t))
		return SY_OUT_OF_MEMORY;

#ifdef SY_DEBUG
	sy_debug(sy, "\t");
	sy_dump_opstack(sy);
	sy_debug(sy, " PSH \"%s\" -> ", token == NONE ? "NONE" : op_desc(token));
#endif

	*(sy->opstack - 1 - sy->opstack_next++)  = token;

#ifdef SY_DEBUG
	sy_dump_opstack(sy);
	sy_debug(sy, "\n");
#endif

	return 0;
}

static int sy_pop_op(struct sy_state *sy)
{
	int token;

#ifdef SY_DEBUG
	sy_debug(sy, "\t");
	sy_dump_opstack(sy);
#endif

	if (sy->opstack_next > 0)
		token = *(sy->opstack -1 - --sy->opstack_next);
	else
		token = NONE;

#ifdef SY_DEBUG
	sy_debug(sy, " POP \"%s\"", token == NONE ? "NONE" : op_desc(token));
	sy_debug(sy, " -> ");
	sy_dump_opstack(sy);
	sy_debug(sy, "\n");
#endif

	return token;
}

static inline bool sy_should_pop_op(struct sy_state *sy, int token)
{
	bool ret;
	int top;

	/* no ops in stack? can't pop */
	if (sy_opstack_count(sy) <= 0)
		return false;

	/* always pop for EOF */
	if (token == NONE)
		return true;

	/* right parentheses? pop always until lparen */
	if (token == RPAREN)
		return true;

	top = sy_op_top(sy);

	/* left parentheses? always push */
	if (top == LPAREN)
		return false;

	/* colon? always pop until ? */
	if (token == COLON)
		return top != QMARK && top != COLON;

	ret = false;
	/* left associative, pop on equal */
	if ((is_left_assoc(token)  && op_prec(top) <= op_prec(token)) ||
	    (is_right_assoc(token) && op_prec(top) <  op_prec(token)))
		ret = is_unary(token) ? is_unary(top) : true; /* unaries only pop unaries */

	return ret;
}

static int sy_handle_op(struct sy_state *sy, int token)
{
	sy_val_t val1, val2, val3, val;
	int pop_token;
	int ret;
#ifdef SY_DEBUG
	char vstr[SY_VAL_STR_LEN_MAX * 4];
	char *vs = vstr;
	int vl = sizeof(vstr);
#endif

	pop_token = NONE;
	while (sy_should_pop_op(sy, token)) {

		pop_token = sy_pop_op(sy);

		if (pop_token == NONE)
			return SY_NO_OP_IN_STACK;

		/* poped everything until left paren found */
		if (token == RPAREN && pop_token == LPAREN)
			break;

		if (is_ternary(pop_token)) {

			if (sy_queue_count(sy) < 3)
				return SY_NOT_ENOUGH_TERNARY_VALUES;

			if ((ret = sy_dequeue_val(sy, &val3)) ||
			    (ret = sy_dequeue_val(sy, &val2)) ||
			    (ret = sy_dequeue_val(sy, &val1)) )
				return ret;

			switch (pop_token) {
			case QMARK:
				/* ternary op value inherits the selected expr */
				val.v = val1.v ? val2.v : val3.v;
				val.u = val1.u ? val2.u : val3.u;
				val.x = val1.x ? val2.x : val3.x;
				break;
			default:
				return SY_UNKNOWN_TERNARY_OP;
			}

			sy_debug(sy, "\tEVL %s = %s %s %s %s %s\n",
				sy_val_str_multi(&val, &vs, &vl),
				sy_val_str_multi(&val1, &vs, &vl),
				op_op(pop_token),
				sy_val_str_multi(&val2, &vs, &vl),
				pop_token == QMARK ? op_op(COLON) : "<>",
				sy_val_str_multi(&val3, &vs, &vl));

			ret = sy_queue_val(sy, &val);
			if (ret)
				return ret;

		} else if (is_binary(pop_token)) {

			if (sy_queue_count(sy) < 2)
				return SY_NOT_ENOUGH_BINARY_VALUES;

			if ((ret = sy_dequeue_val(sy, &val2)) ||
			    (ret = sy_dequeue_val(sy, &val1)) )
				return ret;

			switch (pop_token) {
			case LOR:  val.v = val1.v || val2.v; break;
			case LAND: val.v = val1.v && val2.v; break;
			case OR:   val.v = val1.v  | val2.v; break;
			case XOR:  val.v = val1.v  ^ val2.v; break;
			case AND:  val.v = val1.v  & val2.v; break;
			case EQ:   val.v = val1.v == val2.v; break;
			case NE:   val.v = val1.v != val2.v; break;
			case LT:   val.v = val1.v  < val2.v; break;
			case LE:   val.v = val1.v <= val2.v; break;
			case GT:   val.v = val1.v  > val2.v; break;
			case GE:   val.v = val1.v >= val2.v; break;
			case SHL:  val.v = val1.v << val2.v; break;
			case SHR:  val.v = val1.v >> val2.v; break;
			case ADD:  val.v = val1.v  + val2.v; break;
			case SUB:  val.v = val1.v  - val2.v; break;
			case MUL:  val.v = val1.v  * val2.v; break;
			case DIV:
				if (val2.v == 0)
					return SY_DIV_BY_ZERO;
				val.v = val1.v / val2.v;
				break;
			case MOD:
				if (val2.v == 0)
					return SY_MOD_BY_ZERO;
				val.v = val1.v  % val2.v;
				break;
			default:
				return SY_UNKNOWN_BINARY_OP;
			}

			val.u = val1.u || val2.u;
			val.x = val1.x || val2.x;
			sy_debug(sy, "\tEVL %s = %s %s %s\n",
				sy_val_str_multi(&val, &vs, &vl),
				sy_val_str_multi(&val1, &vs, &vl),
				op_op(pop_token),
				sy_val_str_multi(&val2, &vs, &vl));

			ret = sy_queue_val(sy, &val);
			if (ret)
				return ret;

		} else if (is_unary(pop_token)) {

			if (sy_queue_count(sy) < 1)
				return SY_NO_UNARY_VALUE;

			ret = sy_dequeue_val(sy, &val1);
			if (ret)
				return ret;

			switch (pop_token) {
			case UPLUS:  val.v = +val1.v; break;
			case UMINUS: val.v = -val1.v; break;
			case LNOT:   val.v = !val1.v; break;
			case NOT:    val.v = ~val1.v; break;
			default:
				return SY_UNKNOWN_UNARY_OP;
			}
			val.u = val1.u;
			val.x = val1.x;

			sy_debug(sy, "\tEVL %s = %s %s\n",
				sy_val_str_multi(&val, &vs, &vl),
				op_op(pop_token),
				sy_val_str_multi(&val1, &vs, &vl));

			ret = sy_queue_val(sy, &val);
			if (ret)
				return ret;
		} else if (pop_token == QMARK)
			return SY_STRAY_QMARK;
		else if (pop_token == COLON)
			;	/* nothing on COLON */
		else
			return SY_UNKNOWN_OP;

		if (token == COLON && pop_token == QMARK)
			break;
	}

	/* if we popped with ) it should end with ( */
	if (token == RPAREN && pop_token != LPAREN)
		return SY_UNMATCHED_RPAREN;

	/* pushing colon should have a ? at the top */
	if (token == COLON && sy_op_top(sy) != QMARK)
		return SY_UNMATCHED_COLON;

	return 0;
}

static int sy_parse_op(struct sy_state *sy, const char *str, int len,
		       int *oplenp)
{
	const struct sy_opdesc *op;
	int token, oplen, last_token;

	for (token = NONE + 1; token < ARRAY_SIZE(ops); token++) {
		op = ops + token;
		oplen = strlen(op->op);
		if (oplen <= len && !memcmp(op->op, str, oplen))
			break;
	}

	if (token >= ARRAY_SIZE(ops))
		return SY_SYNTAX_ERROR;

	last_token = sy_get_last_token(sy);
	/* differentiate between binary operators and unary operators */
	if ((token == ADD || token == SUB) && is_operator(last_token))
		token = token == ADD ? UPLUS : UMINUS;

	if (oplenp)
		*oplenp = oplen;

	return token;
}

static int sy_parse_token(struct sy_state *sy, const char *str, int len,
			  sy_val_t *valp, int *advp)
{
	const char *s, *e;
	char c, *end;
	int token;
	char buf[SY_VAL_STR_LEN_MAX];

	*advp = 0;

	s = str;
	e = s + len;
	if (s >= e)
		return NONE;

	c = *s++;
	if (c == '\'') {
		if (s >= e)
			return SY_BAD_CHAR_LITERAL;
		c = *s++;
		if (c == '\0')
			return SY_BAD_CHAR_LITERAL;
		if (c == '\\') {
			if (s >= e)
				return SY_BAD_CHAR_LITERAL;
			c = *s++;
			switch (c) {
			case 'a': c = '\a'; break;
			case 'b': c = '\b'; break;
			case 't': c = '\t'; break;
			case 'n': c = '\n'; break;
			case 'v': c = '\v'; break;
			case 'f': c = '\f'; break;
			case 'r': c = '\r'; break;
			default:
				  return SY_BAD_CHAR_LITERAL;
			}
		}
		if (s >= e)
			return SY_BAD_CHAR_LITERAL;
		c = *s++;
		if (c != '\'')
			return SY_BAD_CHAR_LITERAL;
		valp->v = (sy_val_v_t)c;
		valp->u = true;
		valp->x = true;
		token = LITERAL;
		*advp = s - str;

	} else if (isdigit(c)) {
		errno = 0;

		/* always copy to small temp buffer */
		if (len >= sizeof(buf) - 1)
			len = sizeof(buf) - 1;
		strncpy(buf, str, len);
		buf[len] = '\0';
		str = buf;

		/* first try as signed */
		valp->v = strtoul(str, &end, 0);
		valp->u = false;
		if (errno == ERANGE) {
			/* now try as unsigned */
			errno = 0;
			valp->v = strtoull(str, &end, 0);
			if (errno == ERANGE)
				return SY_NUMBER_OUT_OF_RANGE;
			valp->u = true;
		}
		valp->x = str[0] == '0' && str[1] == 'x';

		if (errno)
			return SY_NUMBER_PARSE_ERROR;

		/* skip over L */
		if (*end == 'L') {
			end++;
			if (*end == 'L')
				end++;
		}

		if (*end == 'U') {
			valp->u = true;
			end++;
		}

		token = LITERAL;
		*advp = end - str;
	} else
		token = sy_parse_op(sy, str, len, advp);

	return token;
}

void sy_init(struct sy_state *sy, const struct sy_config *cfg)
{
	intptr_t p;

	sy->last_token = NONE;
	sy->pos = -1;
	sy->errcode = 0;

	p = (intptr_t)cfg->workbuf;

	/* align to sy_val_v_t */
	sy->valq = (void *)ALIGN(p, sizeof(sy_val_v_t));
	sy->valq_next = 0;

	/* op is always aligned (since it's char type */
	sy->opstack = cfg->workbuf + cfg->size;
	sy->opstack_next = 0;

#ifdef SY_DEBUG
	sy->debugf = cfg->debugf;
	sy->debugarg = cfg->debugarg;
#endif
}

int sy_eval(struct sy_state *sy, const char *str, int len, sy_val_t *valp)
{
	const char *s;
	const char *e;
	sy_val_t val;
	char c;
	int last_token, token, oplen, ret;

	s = str;
	if (len <= 0)
		len = strlen(str);

	/* verify that we have enough space for worst case */
	if (sy_workbuf_space(sy) < sy_workbuf_size_max(len))
		return sy_set_error(sy, SY_WORKBUF_TOO_SMALL);

	e = s + len;
	while (s < e && (c = *s) != '\0') {
		if (isspace(c)) {
			s++;
			continue;
		}

		sy->pos = s - str;

		ret = sy_parse_token(sy, s, (int)(e - s), &val, &oplen);
		if (ret < 0)
			return sy_set_error(sy, ret);
		token = ret;

		sy_debug(sy, "* token=");
		sy_dump_token(sy, token, &val);

		if (token == NONE)
			return sy_set_error(sy, SY_OUT_OF_INPUT);

		last_token = sy_get_last_token(sy);

		/* operand cannot follow operand */
		if (is_operand(last_token) &&
		    (is_operand(token) && token != RPAREN))
			return sy_set_error(sy, SY_SYNTAX_ERROR);

		/* non unary operators back to back not allowed */
		if (is_operator(last_token) &&
		    (is_operator(token) && !is_unary(token) && token != LPAREN))
			return sy_set_error(sy, SY_SYNTAX_ERROR);

		if (token == LITERAL) {
			ret = sy_queue_val(sy, &val);
			if (ret < 0)
				return sy_set_error(sy, ret);
		} else {
			ret = sy_handle_op(sy, token);
			if (ret < 0)
				return sy_set_error(sy, ret);

			if (is_pushable(token)) {
				ret = sy_push_op(sy, token);
				if (ret < 0)
					return sy_set_error(sy, ret);
			}
		}

		s += oplen;
		assert(s <= e);
		sy_set_last_token(sy, token);
	}

	sy_debug(sy, "* No more input; evaluating\n");

	/* EOF */
	sy->pos = s - str;
	ret = sy_handle_op(sy, NONE);
	if (ret < 0)
		return sy_set_error(sy, ret);

	if (sy_opstack_count(sy) > 0)
		return sy_set_error(sy, SY_BAD_EOF_OP_STACK);

	if (sy_queue_count(sy) != 1)
		return sy_set_error(sy, SY_BAD_EOF_VALUE_QUEUE);

	ret = sy_dequeue_val(sy, valp);
	if (ret < 0)
		return sy_set_error(sy, ret);

	return 0;
}

#ifdef SY_VERBOSE_ERROR_REPORTING

static const char *sy_error(int error)
{
	switch (error) {
	case SY_NO_OP_IN_STACK:
		return "No operand in stack";
	case SY_NOT_ENOUGH_TERNARY_VALUES:
		return "Not enough values for ternary op";
	case SY_NOT_ENOUGH_BINARY_VALUES:
		return "Not enough values for binary op";
	case SY_NO_UNARY_VALUE:
		return "Not enough values for unary op";
	case SY_DIV_BY_ZERO:
		return "Division by zero";
	case SY_MOD_BY_ZERO:
		return "Modulus by zero";
	case SY_UNKNOWN_TERNARY_OP:
		return "Unknown ternary op";
	case SY_UNKNOWN_BINARY_OP:
		return "Unknown binary op";
	case SY_UNKNOWN_UNARY_OP:
		return "Unknown unary op";
	case SY_UNKNOWN_OP:
		return "Unknown op";
	case SY_SYNTAX_ERROR:
		return "Syntax error";
	case SY_OUT_OF_MEMORY:
		return "Out of memory";
	case SY_NUMBER_OUT_OF_RANGE:
		return "Number out of range";
	case SY_NUMBER_PARSE_ERROR:
		return "Number parse error";
	case SY_BAD_CHAR_LITERAL:
		return "Bad character literal";
	case SY_OUT_OF_INPUT:
		return "Out of input";
	case SY_UNMATCHED_RPAREN:
		return "Unmatched right parentheses \")\"";
	case SY_UNMATCHED_COLON:
		return "Unmatched colon \":\"";
	case SY_UNMATCHED_UNKNOWN:
		return "Unknown unmatched op";
	case SY_BAD_EOF_VALUE_QUEUE:
		return "Bad value queue state on EOF";
	case SY_BAD_EOF_OP_STACK:
		return "Bad op stack state on EOF";
	case SY_INTERNAL_ERROR:
		return "Internal error";
	case SY_WORKBUF_TOO_SMALL:
		return "Work buffer is too small";
	case SY_STRAY_QMARK:
		return "Stray question mark";
	default:
		break;
	}
	return "Uknown error";
}

#endif

int sy_get_error(struct sy_state *sy, int *pos, const char **errmsg)
{
	if (!sy->errcode) {
		*pos = 0;
		*errmsg = NULL;
		return 0;
	}
	*pos = sy->pos;
#ifdef SY_VERBOSE_ERROR_REPORTING
	*errmsg = sy_error(sy->errcode);
#else
	*errmsg = "bad expression";
#endif
	return sy->errcode;
}

const char *sy_val_str_multi(const sy_val_t *val, char **buf, int *size)
{
	const char *ret;
	int len;

	if (val->x)
		len = snprintf(*buf, *size, "0x%" SY_PRIx, val->v);
	else if (val->u)
		len = snprintf(*buf, *size, "%" SY_PRIu, val->v);
	else
		len = snprintf(*buf, *size, "%" SY_PRIs,
				(sy_signed_val_v_t)val->v);

	/* possible truncation */
	if (len == *size)
		return "<>";
	len++;

	ret = *buf;

	*size -= len;
	*buf += len;

	return ret;
}

const char *sy_val_str(const sy_val_t *val, char *buf, int size)
{
	return sy_val_str_multi(val, &buf, &size);
}
